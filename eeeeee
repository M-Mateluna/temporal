-- Unicidad por (nombre, tiempocarrera) solo en la función (sin UNIQUE en la tabla)
-- Regla:
--   - Si (nombre, tiempo) ya existe -> actualiza descripcion y devuelve idcarrera
--   - Si no existe -> crea nueva carrera y devuelve idcarrera
-- Comparación de nombre en UPPER(TRIM) para evitar duplicados "cosméticos"

CREATE OR REPLACE FUNCTION evaluacion.fn_carrera_ig(
  _nombre         VARCHAR,
  _descripcion    VARCHAR,
  _tiempocarrera  INTEGER
) RETURNS INTEGER
LANGUAGE plpgsql AS
$$
DECLARE
  _id   INTEGER;
  _nrm  TEXT;   -- nombre normalizado
  _desc TEXT;   -- descripcion normalizada (aquí solo trim; no la forzamos a upper)
BEGIN
  -- Validaciones del enunciado
  IF _nombre IS NULL OR length(btrim(_nombre)) < 5 THEN
    RAISE EXCEPTION 'NOMBRE CARRERA OBLIGATORIO (≥ 5 CARACTERES)';
  END IF;
  IF _descripcion IS NULL OR length(btrim(_descripcion)) = 0 THEN
    RAISE EXCEPTION 'DESCRIPCIÓN OBLIGATORIA';
  END IF;
  IF _tiempocarrera IS NULL OR _tiempocarrera < 1 THEN
    RAISE EXCEPTION 'TIEMPO DE CARRERA DEBE SER ENTERO POSITIVO (≥ 1)';
  END IF;

  _nrm  := upper(btrim(_nombre));
  _desc := btrim(_descripcion);

  -- Evitar duplicados por carrera de concurrencia (sin UNIQUE):
  -- bloqueamos por clave (nombre_normalizado, tiempo)
  PERFORM pg_advisory_xact_lock( (hashtext(_nrm) # _tiempocarrera)::bigint );

  -- 1) ¿Existe por (nombre_normalizado, tiempo)? -> actualizar descripción
  SELECT idcarrera INTO _id
    FROM evaluacion.carrera
   WHERE upper(btrim(nombre)) = _nrm
     AND tiempocarrera        = _tiempocarrera
   LIMIT 1;

  IF FOUND THEN
    UPDATE evaluacion.carrera
       SET descripcion = _desc
     WHERE idcarrera = _id;
    RETURN _id;
  END IF;

  -- 2) No existe -> crear nueva
  INSERT INTO evaluacion.carrera(nombre, descripcion, tiempocarrera)
  VALUES (_nombre, _desc, _tiempocarrera)
  RETURNING idcarrera INTO _id;

  RETURN _id;
END;
$$;
