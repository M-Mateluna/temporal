SET SEARCH_PATH TO votaciones, public;

-- =========================
-- LISTADOS (1 tabla => SIN alias)
-- =========================

CREATE OR REPLACE FUNCTION fn_listar_regiones()
RETURNS TABLE(id INT, nombre TEXT) AS
$$
BEGIN
  RETURN QUERY
  SELECT idregion, nombre
  FROM votaciones.region
  ORDER BY nombre ASC;
END;
$$ LANGUAGE plpgsql STABLE;

CREATE OR REPLACE FUNCTION fn_listar_comunas(_idregion INT)
RETURNS TABLE(id INT, nombre TEXT) AS
$$
BEGIN
  RETURN QUERY
  SELECT idcomuna, nombre
  FROM votaciones.comuna
  WHERE idregion = _idregion
  ORDER BY nombre ASC;
END;
$$ LANGUAGE plpgsql STABLE;

CREATE OR REPLACE FUNCTION fn_listar_candidatos()
RETURNS TABLE(id INT, nombre TEXT) AS
$$
BEGIN
  RETURN QUERY
  SELECT idcandidato, nombre
  FROM votaciones.candidato
  ORDER BY nombre ASC;
END;
$$ LANGUAGE plpgsql STABLE;

CREATE OR REPLACE FUNCTION fn_listar_fuentes()
RETURNS TABLE(id INT, nombre TEXT) AS
$$
BEGIN
  RETURN QUERY
  SELECT idfuente, nombre
  FROM votaciones.fuente
  ORDER BY nombre ASC;
END;
$$ LANGUAGE plpgsql STABLE;

-- =========================
-- REGISTRAR VOTO (validaciones)
-- =========================
CREATE OR REPLACE FUNCTION fn_registrar_voto(
  _nombreapellido VARCHAR,
  _alias          VARCHAR,
  _rut            VARCHAR,
  _email          VARCHAR,
  _idregion       INT,
  _idcomuna       INT,
  _idcandidato    INT,
  _idfuentes      INT[]
)
RETURNS TABLE(idvoto INT) AS
$$
DECLARE
  __idvoto           INT;
  __count            INT;
  __okcomuna         INT;
  __fuentes_validas  INT;
BEGIN
  -- ALIAS: >5, alfanumérico, debe incluir letras y números
  IF _alias IS NULL OR LENGTH(_alias) <= 5 THEN
    RAISE EXCEPTION 'ALIAS INVALIDO: DEBE SER MAYOR A 5 CARACTERES';
  END IF;
  IF _alias !~ '^[A-Za-z0-9]+$' OR _alias !~ '[A-Za-z]' OR _alias !~ '[0-9]' THEN
    RAISE EXCEPTION 'ALIAS INVALIDO: DEBE SER ALFANUMERICO Y CONTENER LETRAS Y NUMEROS';
  END IF;

  -- EMAIL simple
  IF _email IS NULL OR _email !~ '^[^@]+@[^@]+\.[^@]+$' THEN
    RAISE EXCEPTION 'EMAIL INVALIDO';
  END IF;

  -- COMUNA pertenece a REGION (1 tabla => SIN alias)
  SELECT COUNT(*) INTO __okcomuna
  FROM votaciones.comuna
  WHERE idcomuna = _idcomuna AND idregion = _idregion;
  IF __okcomuna = 0 THEN
    RAISE EXCEPTION 'LA COMUNA NO PERTENECE A LA REGION';
  END IF;

  -- RUT único (1 tabla => SIN alias)
  SELECT COUNT(*) INTO __count
  FROM votaciones.voto
  WHERE rut = _rut;
  IF __count > 0 THEN
    RAISE EXCEPTION 'EL RUT % YA REGISTRO UN VOTO', _rut
      USING ERRCODE = 'unique_violation';
  END IF;

  -- FUENTES: al menos 2 y deben existir (1 tabla => SIN alias)
  IF _idfuentes IS NULL OR ARRAY_LENGTH(_idfuentes, 1) < 2 THEN
    RAISE EXCEPTION 'DEBE SELECCIONAR AL MENOS DOS FUENTES';
  END IF;

  SELECT COUNT(*) INTO __fuentes_validas
  FROM votaciones.fuente
  WHERE idfuente = ANY (_idfuentes);

  IF __fuentes_validas <> ARRAY_LENGTH(_idfuentes, 1) THEN
    RAISE EXCEPTION 'EXISTEN FUENTES INVALIDAS';
  END IF;

  -- INSERTAR VOTO (fecha es DATE con DEFAULT CURRENT_DATE)
  INSERT INTO votaciones.voto(
    nombreapellido, alias, rut, email, idregion, idcomuna, idcandidato
  ) VALUES (
    _nombreapellido, _alias, _rut, _email, _idregion, _idcomuna, _idcandidato
  )
  RETURNING votaciones.voto.idvoto INTO __idvoto;

  -- INSERTAR FUENTES (N:M)
  INSERT INTO votaciones.votofuente(idvoto, idfuente)
  SELECT __idvoto, UNNEST(_idfuentes);

  RETURN QUERY SELECT __idvoto;
END;
$$ LANGUAGE plpgsql VOLATILE;

-- =========================
-- RESUMEN (JOIN => CON alias y campos calificados)
-- =========================
CREATE OR REPLACE FUNCTION fn_resumen_votos()
RETURNS TABLE(candidato TEXT, total BIGINT) AS
$$
BEGIN
  RETURN QUERY
  SELECT ca.nombre AS candidato, COUNT(*)::BIGINT AS total
  FROM votaciones.voto v
  INNER JOIN votaciones.candidato ca
    ON v.idcandidato = ca.idcandidato
  GROUP BY ca.nombre
  ORDER BY COUNT(*) DESC, ca.nombre;
END;
$$ LANGUAGE plpgsql STABLE;
